####################################################
print('[ 정수형 ]')

a = 1000
print('양의 정수: ', a)

b = -7
print('음의 정수:', b)

c = 0
print(c)

####################################################
print('\n[ 실수형 ]')

d = 157.93
print('양의 실수: ', d)

e = -1837.2
print('임의 실수:', e)

f = 5.
print('소수부가 0일 때 0을 생략: ', f)
f = -5.
print('소수부가 0일 때 0을 생략', f)

g = .7
print('정수부가 0일 때 0을 생략', g)
g = -.7
print('정수부가 0일 때 0을 생략', g)

####################################################
print('\n[ 실수형 지수 표현 방식 ]')
# 유효숫자e지수 = 유효숫자x10지수

# 10억의 지수 표현 방식
h = 1e9
print(h)

# 752.5
i = 75.25e1
print(i)

# 3.954
j = 3954e-3
print(j)

####################################################
print('\n[ 2진수 실수 표현의 오류 ]')

k = 0.3 + 0.6
print(k)

if a == 0.9:
    print(True)
else:
    print(False)

####################################################
print('\n[ 소수점 값을 비교하는 작업은 round() 함수를 이용 ]')
# 두번째 인자, 반올림하고자 하는 위치 -1
# 두번째 인자를 비우면 소수점 첫째 자리에서 반 올림

# 123.46
print(round(123.456, 2))

k = 0.3 + 0.6
print(round(k, 1))

if round(k, 1) == 0.9:
    print(True)
else:
    print(False)

####################################################
print('\n[ 수 자료형의 연산 ]')

l = 7
n = 3

# 나누기 / | 2.3333333333
print(l / n)

# 나머지 % | 1
print(l % n)

# 몫 // | 2
print(l // n)

# 거듭제곱 ** | 343
print(l ** n)

####################################################
print('\n[ 리스트 자료형 ]')

m = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(m)

# 인덱스4, 다섯 번째 원소에 접근
print(m[4])

# 빈 리스트 선언법 1
print(list())

# 빈 리스트 선언법 2
print([])

# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
o = [0] * n
print(o)

####################################################
print('\n[ 리스트의 인덱싱과 슬라이싱 ]')
# 특정한 원소에 접근하는 것을 인덱싱이라 한다.

p = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 뒤에서 첫 번째 원소 출력
print(p[-1])

# 뒤에서 세 번째 원소 출력
print(p[-3])

# 네 번째 원소 값 변경
p[3] = 99
print(p)

# 리스트에서 연속적인 위치를 갖는 원소들을 가져오는 것을 슬라이싱이라 한다.
# 시작 인덱스 : (끝 인덱스-1)

# 두 번째 원소 부터 네 번째 원소까지
print(p[1:4])

####################################################
print('\n[ 리스트 컴프리헨션 ]')
# 리스트 초기화 방법 중 하나, 조건문과 반복문을 활용한 리스트 초기화 가능

# 0 ~ 19까지의 수 중에서 홀수만 포함하는 리스트
# 리스트 컴프리헨션을 사용하지 않는 방식
array1 = []
for i in range(20):
    if i % 2 == 1:
        array1.append(i)
print(array1)

# 리스트 컴프리헨션을 사용한 방식
array2 = [i for i in range(20) if i % 2 == 1]
print(array2)

# 1 ~ 9까지의 수의 제곱 값을 포함하는 리스트
array3 = [i*i for i in range(1, 10)]
print(array3)

# n x m 크기의 2차원 리스트 초기화
# 파이썬에서는 반복을 수행하되, 변수 값이 필요 없을 때 언더바(_)를 사용할 수 있다.
m = 2
n = 4
array4 = [[0] * m for _ in range(n)]
print(array4)

# n x m 크기의 2차원 리스트 초기화 (잘못된 방법)
# 특정 크기의 2차원 리스트를 초기화할 때는 반드시 리스트 컴프리헨션을 이용해야 한다.
m = 2
n = 4
array5 = [[0] * m] * n
print(array5)

# 4개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식 되기 때문에 하나만 바꿔도 전부 다 바뀐걸로 나옴
array5[1][1] = 5
print(array5)
array5[2][1] = 6
print(array5)

####################################################
print('\n[ 리스트 관련 기타 메서드 ]')

a = [1, 4, 3]
print('기본 리스트: ', a)

a.append(2)
print('리스트에 원소 삽입: ', a)

a.sort()
print('오름차순 정렬: ', a)

a.sort(reverse=True)
print('내림차순 정렬: ', a)

a.reverse()
print('원소 뒤집기: ', a)

a.insert(2, 3)
print('인덱스 2 위치에 3 추가: ', a)

print('값이 3인 데이터의 개수: ', a.count(3))

# 해당 값을 가진 원소가 여러개면 한개만 제거
a.remove(3)
print('값이 3인 데이터 삭제: ', a)

a = [1,2,3,3,4,5,5,5]
remove_set = {3,5}
result = [i for i in a if i not in remove_set]
print('특정한 값의 원소를 전부 제거한 새 리스트: ', result)